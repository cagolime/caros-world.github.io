-- Run this in Supabase SQL editor.

create table if not exists public.profiles (
  id uuid primary key references auth.users(id) on delete cascade,
  username text not null unique check (char_length(username) between 3 and 24),
  login_email text not null unique,
  created_at timestamptz not null default now()
);

create table if not exists public.posts (
  id bigint generated by default as identity primary key,
  user_id uuid not null references public.profiles(id) on delete cascade,
  content text not null check (char_length(content) between 1 and 1000000),
  created_at timestamptz not null default now()
);

alter table public.profiles enable row level security;
alter table public.posts enable row level security;

alter table public.profiles add column if not exists login_email text;
create unique index if not exists profiles_login_email_idx on public.profiles (login_email) where login_email is not null;
update public.profiles p
set login_email = lower(u.email)
from auth.users u
where p.id = u.id and (p.login_email is null or p.login_email = '');

drop policy if exists "profiles read" on public.profiles;
create policy "profiles read"
on public.profiles for select
using (true);

drop policy if exists "profiles write own" on public.profiles;
create policy "profiles write own"
on public.profiles for insert
with check (auth.uid() = id);

drop policy if exists "profiles update own" on public.profiles;
create policy "profiles update own"
on public.profiles for update
using (auth.uid() = id)
with check (auth.uid() = id);

drop policy if exists "posts read" on public.posts;
create policy "posts read"
on public.posts for select
using (true);

drop policy if exists "posts write own" on public.posts;
create policy "posts write own"
on public.posts for insert
with check (auth.uid() = user_id);

alter table public.posts drop constraint if exists posts_content_check;
alter table public.posts add constraint posts_content_check check (char_length(content) between 1 and 1000000);

create index if not exists posts_created_at_idx on public.posts (created_at desc);

insert into storage.buckets (id, name, public, file_size_limit, allowed_mime_types)
values (
  'post-images',
  'post-images',
  true,
  5242880,
  array['image/png', 'image/jpeg', 'image/webp', 'image/gif']
)
on conflict (id) do update
set public = excluded.public;

drop policy if exists "post_images_read" on storage.objects;
create policy "post_images_read"
on storage.objects for select
using (bucket_id = 'post-images');

drop policy if exists "post_images_insert_own_folder" on storage.objects;
create policy "post_images_insert_own_folder"
on storage.objects for insert
with check (
  bucket_id = 'post-images'
  and auth.uid()::text = (storage.foldername(name))[1]
);

drop policy if exists "post_images_update_own_folder" on storage.objects;
create policy "post_images_update_own_folder"
on storage.objects for update
using (
  bucket_id = 'post-images'
  and auth.uid()::text = (storage.foldername(name))[1]
)
with check (
  bucket_id = 'post-images'
  and auth.uid()::text = (storage.foldername(name))[1]
);

drop policy if exists "post_images_delete_own_folder" on storage.objects;
create policy "post_images_delete_own_folder"
on storage.objects for delete
using (
  bucket_id = 'post-images'
  and auth.uid()::text = (storage.foldername(name))[1]
);
